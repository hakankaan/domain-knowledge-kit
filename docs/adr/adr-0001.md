---
id: adr-0001
title: Adopt Vertical Slice Architecture
status: accepted
date: 2026-02-20
deciders:
  - Kaan Akın
---

# ADR-0001 — Adopt Vertical Slice Architecture

**Status:** Accepted  
**Date:** 2026-02-20  
**Deciders:** Kaan Akın

## Context

The codebase originally followed a classic layered architecture with directories
organized by technical concern: `commands/`, `core/`, `types/`, and `utils/`.
This structure introduced several pain points as the project grew:

- **Duplication of structural iteration.** The "iterate all item types in a
  bounded context" pattern was duplicated in 5+ locations across layers
  (`graph.ts`, `validator.ts`, `renderer.ts`, `indexer.ts`, `list.ts`).
- **Tight coupling through the loader.** Every command depended directly on
  `core/loader.ts`, creating uniform coupling regardless of command complexity.
- **Layer-oriented tests.** Tests were organized by architectural layer rather
  than by feature, making it difficult to reason about feature-level correctness
  or to navigate from a feature to its tests.
- **High change amplification.** Adding a new domain item type required touching
  6+ files across different directories.

## Decision

Adopt a **vertical slice architecture** with three feature slices plus a shared
infrastructure module:

```
src/
  cli.ts                          # Slim entry point
  shared/                         # Cross-cutting infrastructure
    types/domain.ts               # DomainModel, all interfaces
    types/index.ts                # SearchIndexRecord
    loader.ts                     # loadDomainModel()
    graph.ts                      # Graph utilities (BFS traversal)
    item-visitor.ts               # Generic item-type visitor
    adr-parser.ts                 # ADR frontmatter parser
    paths.ts                      # Path resolution
    yaml.ts                       # YAML parsing
    errors.ts                     # Error types
    index.ts                      # Barrel exports
    tests/                        # Shared module tests
  features/
    query/                        # Read-only exploration commands
      commands/                   # list, show, search, related
      searcher.ts                 # Full-text search engine
      tests/                      # Query feature tests
    adr/                          # ADR-specific commands
      commands/                   # adr-show, adr-related
    pipeline/                     # Mutation / generation commands
      commands/                   # validate, render
      validator.ts                # Schema + cross-reference validation
      renderer.ts                 # Markdown documentation renderer
      indexer.ts                  # Search index builder
      tests/                      # Pipeline feature tests
```

Key design choices:

1. **Feature slices own their commands, business logic, and tests.** Each slice
   is self-contained and can be understood in isolation.
2. **An `item-visitor` utility** centralizes the "iterate all item types in a
   context" pattern, eliminating the duplication that existed across layers.
3. **`shared/`** holds genuinely cross-cutting infrastructure (loader, graph,
   types, YAML parsing) that multiple slices depend on.

## Consequences

### Positive

- **Co-located tests:** Tests live next to the code they exercise, making them
  easy to discover by navigating to the feature directory.
- **Reduced duplication:** The item-visitor utility provides a single place to
  handle structural iteration over domain item types.
- **Lower change amplification:** Adding a new domain item type now requires
  updating only the visitor utility and the item type definitions, rather than
  touching files scattered across multiple layers.
- **Feature isolation:** Each slice can evolve independently; changes to the
  pipeline (e.g., a new validation rule) don't touch query code.

### Negative

- **`shared/` has high fan-in:** The loader and types modules are imported by
  every slice. This reflects a genuine shared domain need but means changes to
  shared infrastructure can still ripple across slices.
- **Three slices may not be the final number:** As the project grows, new
  feature areas may warrant additional slices, requiring judgment about when to
  split versus extend.

### Neutral

- The CLI entry point (`cli.ts`) remains a thin wiring layer that imports
  command handlers from each feature slice and registers them.
